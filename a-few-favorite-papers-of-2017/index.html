<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
	<title>A few favorite papers of 2017</title>
	
	<meta name="description" content="">
	<meta name="image" content="">
	
	<meta itemprop="name" content="A few favorite papers of 2017">
	<meta itemprop="description" content="">
	<meta itemprop="image" content="">
	
	<meta name="og:title" content="A few favorite papers of 2017">
	<meta name="og:description" content="">
	
	<meta name="og:url" content="https://rachitsingh.com/a-few-favorite-papers-of-2017/">
	<meta name="og:site_name" content="A few favorite papers of 2017">
	<meta name="og:type" content="article">
	
	<meta name="article:author" content="Rachit Singh">
	<meta name="article:tag" content="">
	<link rel="stylesheet" type="text/css" href="/css/style.css">
	
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.css">
	<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/contrib/auto-render.min.js"></script>
	<link href="https://fonts.googleapis.com/css?family=Lora:400,400i,700" rel="stylesheet">
</head>

<body>



<div id="loadingMask" style="width: 100%; height: 100%; position: fixed; background: #fff;"></div>
<script>
function fadeOut(el) {
  el.style.opacity = 1;

  var last = +new Date();
  var tick = function() {
    el.style.opacity = +el.style.opacity - (new Date() - last) / 80;
    last = +new Date();
    

    if (el.style.opacity > 0) {
      (window.requestAnimationFrame && requestAnimationFrame(tick)) || setTimeout(tick, 16);
    } else {
    	el.style.display='none';
    }
  };

  tick();
}

function ready(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
         el = document.getElementById('loadingMask');
         fadeOut(el);
        var elements = document.querySelectorAll("img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("alt")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("alt"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });

    } else {
        document.addEventListener('DOMContentLoaded', fn);
    }
}
window.onload = ready;
</script>

<div class="content">
	<h1>A few favorite papers of 2017 <aside><a href="/" class="w3-tag">home</a>&nbsp;&nbsp;&nbsp;</aside></h1>
	<p>This isn't an exhaustive list, and I will inevitably forget some papers. I'll keep updating as a remember, and will probably expand some of the background/contribution sections as I have time, so that they're more accessible.</p>

<h2 id="breaking-the-softmax-bottleneck-a-highrank-rnn-language-model-linkhttpsarxivorgpdf171103953pdf">Breaking the Softmax Bottleneck: A High-Rank RNN Language Model [<a href="https://arxiv.org/pdf/1711.03953.pdf">link</a>]</h2>

<p><strong>Background</strong>: Language models and NLP tasks almost always use a softmax to compute a distribution over the vocabulary, and usually this is computed as <span  class="math">\(\sigma(\mathbf{W}\mathbf{h})\)</span>, where <span  class="math">\(\mathbf{h}\)</span> is a <span  class="math">\(d\)</span>-dimensional context vector from a previous layer, and <span  class="math">\(\mathbf{W} \in \mathbb{R}^{M \times d}\)</span> is a word embedding, letting $M$ be the vocabulary size. In language modeling, the model might generate a sequence of contexts <span  class="math">\(\mathbf{h}_1, \ldots, \mathbf{h}_N\)</span> <sup class="footnote-ref" id="fnref:1"><a class="footnote" href="#fn:1">1</a></sup>. Taking the probability vector for each word and stacking it gives a probability matrix <span  class="math">\(\mathbf{A}\)</span>, generated by the model <sup class="footnote-ref" id="fnref:2"><a class="footnote" href="#fn:2">2</a></sup>.</p>

<p><strong>Contribution</strong>: The authors show that the probability matrix is inherent limited in rank by the dimension of the embedding. This is bad, because there are a set of probability distributions that we can't even represent using our model! So no matter how good we are at the architecture beforehand (using all sorts of fancy dropouts / weight drops / etc.), we are limited by this &quot;softmax bottleneck&quot;. Note that <span  class="math">\(d \approx 300\)</span>, and the maximum rank of this matrix is <span  class="math">\(M\)</span>, which is usually 2 orders of magnitude larger. The (simple) solution? Just blending together the softmaxes from <span  class="math">\(k\)</span> different embeddings. They train this new model, reducing <span  class="math">\(d\)</span> to make the number of parameters comparable, and get a ~4 PPL reduction from the previous SOTA on PTB + WikiText.</p>

<p><strong>Why I like this</strong>: It's so simple! And yet, somewhat surprising at the same time. It's the kind of thing I worried about briefly (in an abstract way, without the framework they've provided) when I first learned about softmaxes, but then kind of brushed away. And yet they've shown that just adding simple correction will make models better. It's transferable to translation / summarization models, and I think whenever I think about a probabilistic model I'll think briefly about what kinds of probability distributions are representable.</p>

<h2 id="understanding-blackbox-predictions-via-influence-functions-linkhttpsarxivorgabs170304730">Understanding Black-box Predictions via Influence Functions [<a href="https://arxiv.org/abs/1703.04730">link</a>]</h2>

<p><strong>Background</strong>: This paper falls under the umbrella of 'interpretability', which is a heated subject in the research world at the moment.</p>

<p><strong>Contribution</strong>: This paper (1) looks at earlier work (Cook &amp; Weisberg, 1982) explaining how the parameters of a learned model might change slightly (i.e., the gradient of the parameters) when we change the weighting of datapoints. It uses this via the chain rule to look at the gradient of the <em>test loss</em> with respect to upweight/downweighting a data point. Then, it finds (somewhat) fast algorithms for computing this loss, and applies it to some (small) neural networks. Essentially, it finds a method for 'walking in the space of images' to find a training image that can make your model screw up. Think: insert a random datapoint into the online MNIST files, and suddenly your model is horrible. Note that Yann LeCun doesn't use https on <a href="http://yann.lecun.com/exdb/mnist/">that website</a>.</p>

<p><strong>Why I like this</strong>: I'm a big fan of this paper because it uses some fundamental research on influence functions in a new way. Also, the framework it proposes, that of adversarial training images, is definitely interesting. There are some caveats, of course, with work like this: (non)convexity, complicated models (for which the Hessian is not easy!), efficiency, and the authors treat those issues head-on, rather than brushing them aside. That being said, it's unclear whether it'll work without some more algorithmic refinement (a problem I tackled a bit this semester but didn't make much progress on). I also have an implementation of this work in PyTorch that I hope to open source soon, since it's a little nontrivial and probably of use. This is now possible since PyTorch has some support for automatic HVP calculations.</p>

<h2 id="unbiased-markov-chain-monte-carlo-with-couplings-linkhttpsarxivorgabs170803625">Unbiased Markov chain Monte Carlo with couplings [<a href="https://arxiv.org/abs/1708.03625">link</a>]</h2>

<p>I'm a bit biased because Pierre taught an excellent inference class this spring which I took, but it was definitely interesting to me.</p>

<p><strong>Background</strong>: Because of burn-in, MCMC samples are always biased. The bias can be reduced by extending burn-in, of course, so this might not be a practical concern, but actually burn-in can be a significant contributor (imagine you have to take a few samples from a large set of distributions, like <span  class="math">\(p(x_i | z_i)\)</span> after you've already sampled <span  class="math">\(z_i\)</span> in an ad-hoc way).</p>

<p><strong>Contribution</strong>: This paper shows a method (via coupled chains) that shows how to eliminate bias in MCMC samples.</p>

<!-- **Why I like this**: I think the above scenario of having a high burn-in overhead is not rare, and it's important to know that we can sample in an unbiased way for peace-of-mind purposes. Also, I think it's very foundational, but I might be missing some of the literature here. 

## Attention Is All You Need \[[link](https://arxiv.org/abs/1706.03762)\]

This is a fairly well publicized piece of work, so I probably don't need to say too much about it. Here's [a detailed overview](https://mchromiak.github.io/articles/2017/Sep/12/Transformer-Attention-is-all-you-need/) and [Google's own blog post about it](https://research.googleblog.com/2017/08/transformer-novel-neural-network.html). I don't think I understand it well enough that the idea is 'intuitive', so maybe it doesn't belong in this list, but it's certainly making waves. 

**tldr**: This paper achieves SOTA on NMT (!) with a very novel architecture, by essentially removing all recurrences (since they must process sequentially) and processing in parallel with *multi-headed attention*. It encodes a word's position via an encoding, rather than algorithmically, which has been tried before, but the attention makes it work. Best of all, it is much faster than training a seq2seq model on the same task. 
-->

<p>It's very rare to see a work both push SOTA on a benchmark, <em>and</em> be faster at the same time.</p>

<h2 id="gumbel-softmax--concrete-distribution-linkhttpsarxivorgabs161100712--linkhttpsarxivorgabs161101144">Gumbel Softmax / Concrete Distribution [<a href="https://arxiv.org/abs/1611.00712">link</a>] &amp; [<a href="https://arxiv.org/abs/1611.01144">link</a>]</h2>

<p>I really mean this section to be about these papers and all of the followups, which I think are somewhat natural extensions of the same line of work. See <a href="https://arxiv.org/abs/1703.07370">REBAR</a>, which makes this estimator unbiased by using it as a control variate for the REINFORCE estimator, and <a href="https://arxiv.org/abs/1711.00123">RELAX</a>, which takes things one step further by extending it to the RL paradigm, where you can only sample one action rather than a weighted mix of actions.</p>

<p><strong>Background</strong>: Variational inference is a powerful technique (see Jeffrey's blog post <a href="http://jeffreyling.github.io/2018/01/09/vaes-are-bayesian.html">here</a>), and the research community has made a lot of progress in SVI recently. However, for discrete latent variables, the best we can do is use <a href="https://arxiv.org/abs/1401.0118">black-box variational inference</a>, which is interesting, but very hard to implement and tune <sup class="footnote-ref" id="fnref:3"><a class="footnote" href="#fn:3">3</a></sup>.</p>

<p><strong>Contribution</strong>: These papers give a solution by introducing a relaxation of discrete distributions to distributions over the simplex, and also gives them a reparametrization gradient. Actually, adding Gumbel noise is a common trick in the economics and ranking literature (see: McFadden 1974, Mattson et. al. 2011), but the real innovation here is realizing that taking a softmax over logits + Gumbel noise is reparametrizable, and useful as an approximation to the real argmax (which is the Gumbel max trick). The papers themselves have good explanations, and Eric Jang has a <a href="blog.evjang.com/2016/11/tutorial-categorical-variational.html">nice blog post</a> about how to do it in practice. Actually I think this connection is worth exploring, so I'll go over it in a blog post later.</p>

<p><strong>Why I like this</strong>: It's really useful! Especially with the two follow up works, this is actually a very useful alternative to BBVI (just see the results from <a href="/ibp_vae.pdf">our paper</a>), and makes it much easier to build and train generative models with discrete latent states. For about a month after reading this paper whenever I heard about a generative process I would think: &quot;can this be modeled using a VAE?&quot;. Also, I think the papers are well written.</p>

<h2 id="on-the-quantitative-analysis-of-decoderbased-generative-models-linkhttpsarxivorgabs161104273">On the Quantitative Analysis of Decoder-Based Generative Models [<a href="https://arxiv.org/abs/1611.04273">link</a>]</h2>

<p>I'm not sure if this paper counts as &quot;this year&quot;, but it was in ICLR <em>2017</em> so I'll count it.</p>

<p><strong>Background</strong>: It's difficult to evaluate some generative models. Suppose that there's a latent vector <span  class="math">\(\mathbf{z}\)</span>, and we generate <span  class="math">\(\mathbf{x}\)</span> stepwise, so that <span  class="math">\(\mathbf{z} \sim p(\mathbf{z})\)</span>, and then <span  class="math">\(\mathbf{x} \sim p(\mathbf{x} | \mathbf{z})\)</span>. Then for a hold-out element <span  class="math">\(\mathbf{x}_{\operatorname{test}}\)</span>, we have to integrate out all values of <span  class="math">\(\mathbf{z}\)</span>! This can be expensive, since integration usually means Monte-Carlo sampling. We have some alternatives, like the ELBO or IWAE bounds for VAEs, but even there it is a lower bound, and we're not confident that the ELBO is even asymptotically consistent (the IWAE metric is, but we don't know how fast). For GANs we only seem to have a kernel density estimator (KDE).</p>

<p><strong>Contribution</strong>: First, the authors use bidirectional Monte Carlo (BDMC) to <em>upper bound</em> the log marginal, and show that annealed importance sampling is accurate enough to use to evaluate the quality of other estimates. Then, they use it to evaluate kernel density estimators and IWAE on a number of datasets, and also compare VAEs and GANs (!). They essentially show that IWAE is not quite good enough yet, and KDE is very bad in high dimensional spaces, as expected (it's not even consistent). Also, they show that VAEs are significantly better on evaluation than GANs (since they actually fit to a log-marginal estimator).</p>

<p><strong>Why I like this</strong>: It ties together the promises of a lot of other papers, and has good experimental results, which are cleanly interpreted. I don't think it's foundational, but it gives good motivation for trying to come up with good evaluation metrics for GANs, and lets people know that their concerns about &quot;lower bounds not being good enough&quot; are warranted.</p>

<h2 id="frequentist-consistency-of-variational-bayes">Frequentist Consistency of Variational Bayes</h2>

<p><strong>Background</strong>: Variational bayes / variational inference is well established as a fast alternative to Markov-chain Monte Carlo (MCMC), but we have few theoretical results about it. In particular people are concerned that even discounting the fact that the variational posterior might be misspecified, we don't know that in the large-data limit, the variational posterior is centered at the 'best possible estimate' of the latent variables in some sense, and is asymptotically normal.</p>

<p><strong>Contribution</strong>: Consider just the case of estimating the posterior distributions over <span  class="math">\(\theta\)</span>, the model's parameters (so, shared global latent variables) [^4]. We're being pretty Bayesian here in this sense, so we have a posterior <span  class="math">\(q(\theta)\)</span>. Consider that given <span  class="math">\(\theta\)</span> , we can pick the best possible <span  class="math">\(q(z)\)</span> (in maximizing the ELBO), and pick the best possible <span  class="math">\(\theta\)</span> in this way, and call it the <em>variational frequentist estimate</em> (VFE). Then, assuming that this VFE is consistent, the paper shows (1) the VB posterior <span  class="math">\(q^*(\theta)\)</span> converges to the member of the family that minimizes the KL divergence with a normal centered at the VFE / true parameter, with some variance, and (2) it is consistent. And then they do applications!</p>

<p><strong>Why I liked it</strong>: While it doesn't attempt to tackle all of variatonal inference in one sitting, it is well written and the style of proof reflects how people prove the Bernstein von Mises theorem, so I assume it has the same level of impact (I have a bad sense). Note that there are liberal technical conditions throughout, but they're usually not egregious (see: Robert Nickl's lecture notes on the BVM <a href="http://www.statslab.cam.ac.uk/~nickl/Site/__files/stat2013.pdf">here</a>, which gives some insight). Also, I appreciate these kinds of consistency works because they are difficult, but let us be confident that in the long run the work on variational inference will pay off. Mostly, I like proofs :)</p>

<p><strong>footnotes</strong></p>
<div class="footnotes">

<hr>

<ol>
<li id="fn:1">The paper uses <span  class="math">\(N\)</span> to denote the set of all possible contexts in a language, making some assumptions about finiteness. I'm simplifying here a bit and talking about the contexts in a single sentence which is smaller. The implications are the same, I think.
 <a class="footnote-return" href="#fnref:1"><sup>[return]</sup></a></li>
<li id="fn:2">Note that this idea of a probability matrix assumes that we're using teacher-forcing, which is usual practice in language modeling. In other words, the distribution over word 2 only depends on the context vector, which only depends on the context vector from the previous state and the correct word 1, <strong>not</strong> on our choice of word 1. This isn't a hack - it's the right thing to do when trying to estimate the true log marginal.
 <a class="footnote-return" href="#fnref:2"><sup>[return]</sup></a></li>
<li id="fn:3">Does anyone know of an open-source implementation of BBVI (i.e. control variates and Rao-Blackwellization)? Jeffrey and I worked on this, and we think it's very very expensive to compute the 'correct' control variate as recommended in their paper, based on how PyTorch and Tensorflow are implemented, but we might be missing a detail.
 <a class="footnote-return" href="#fnref:3"><sup>[return]</sup></a></li>
</ol>
</div>

</div>


<footer>

	<p><small><em>Written January 9, 2018. </em>
		 
		Send feedback to <a  href="mailto:rachitsingh@college.harvard.edu">the author</a>.
		
	</small></p>

	<p>
	<a href="/pytorch-internals-curand-and-numerical-instability/">← PyTorch Internals, cuRAND, and numerical instability</a>&nbsp;
	<a href="/persistence-length/" style="float:right;">Persistence Length →</a>
	</p>


</footer>




<script>renderMathInElement(document.body);</script>
</body>
</html>
